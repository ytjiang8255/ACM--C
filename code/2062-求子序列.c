#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#pragma warning(disable: 4996)	//添加的定义排除警告

/*
***************************************************

考虑聚合An = {1,2，...，n}。 例如，A1 = {1}，A3 = {1,2,3}。 
子集序列被定义为非空子集的数组。 按照词典顺序对An的所有子集排序进行排序。 
你的任务是找到第m个。

每个测试情形包含两个数字N和M(0<n<=20，0<m<=总数量的子集的序列)。
输出的m个子集序列中的一个。
1.一个规则的数组，从1...n的
2.对这个数组进行有规则的排序
例如 n=3时
⑴ 1
⑵ 1 2
⑶ 1 2 3
⑷ 1 3
⑸ 1 3 2
⑹ 2
⑺ 2 1
⑻ 2 1 3
⑼ 2 3
⑽ 2 3 1
⑾ 3
⑿ 3 1
⒀ 3 1 2
⒁ 3 2
⒂ 3 2 1
3.问你，给你一个m，让你输出该数组第几个的表达形式
***************************************************
*/

long long c[21], s[21];//c[21]：表示将子集分组后平均每组个数       s[21]：将子集按字典序分组后每组的初始首元素
int main()
{
	int i, j, k, n, t;
	long long m;	//m表示位于第几个子集
	c[1] = 1;
	for (i = 2; i <= 20; i++)
		c[i] = (i - 1)*c[i - 1] + 1;
		//c[i]代表n=i 时，每组的数量，例如c[2]代表n=2时每组有2个
		
	while (scanf("%d%lld", &n, &m) != EOF)
	{
		for (i = 0; i <= 20; i++)
			s[i] = i;		//每循环一次都要把s[21]数组重新归位到首数字，因为之前已经删了出现的
		

		while (n>0 && m>0)	//当n<=0 || m>=0 时，循环结束
		{
			t = m / c[n] + (m%c[n] == 0 ? 0 : 1);//t代表的是在当前排列中是第几个，首数字是多少
			if (t>0)		//若t>0 得到第m个子集在分组后的第t组
			{
				printf("%d", s[t]);
				for (j = t; j <= n; j++)
					s[j] = s[j + 1];//或s[i]+=1 第2个元素在第n个时变为它的下一个数

				m -= ((t - 1)*c[n] + 1);		//减去（t-1组总子集 +1），m变为表示在剩余子集中位于第几个
				printf(m == 0 ? "\n" : " ");
			}
			n--;
		}
	}
	return 0;
}