#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#pragma warning(disable: 4996)	//添加的定义排除警告

/*
***************************************************

每个测试包括四行：
第一行是一个整数L代表跑道的总长度
第二行包含三个整数N，C，T，分别表示充电站的个数，电动车冲满电以后能行驶的距离以及每次充电所需要的时间
第三行也是三个整数VR，VT1，VT2，分别表示兔子跑步的速度，乌龟开电动车的速度，乌龟脚蹬电动车的速度
第四行包含了N(N<=100)个整数p1,p2...pn,分别表示各个充电站离跑道起点的距离，其中0<p1<p2<...<pn<L
其中每个数都在32位整型范围之内。

当乌龟有可能赢的时候输出一行 “What a pity rabbit!"。否则输出一行"Good job,rabbit!";


使用动态规划求解问题，最重要的就是确定动态规划三要素：
    （1）问题的阶段 （2）每个阶段的状态
    （3）从前一个阶段转化到后一个阶段之间的递推关系。
     递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，
	 动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，
	 所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。
    确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，
	最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，
	表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），
	填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，
	最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。
          f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}
个人对动态规划算法的理解：
1：依据题目要求将问题分为若干部，最好为升序排列。
2：求出每一部分的满足题目的最优解，并将其标记。
3：设置边界，递推到边界。
***************************************************
*/
int main()
{
	int N;
	double L, C, T, t1 = 0, t2 = 0;
	double VR, VT1, VT2;
	double dp[105] = { 0 }, p[105] = { 0 }, Min = 0, sum = 0;
	//！！！！主要注意输入格式一定要和定义的数据类型是一样的！！！！！！

	while (scanf("%lf", &L) != EOF)
	{
		scanf("%d%lf%lf", &N, &C, &T);
		scanf("%lf%lf%lf", &VR, &VT1, &VT2);
		for (int i = 1; i <= N; i++)
			scanf("%lf", &p[i]);
		dp[0] = 0; p[0] = 0; p[N + 1] = L;
	
		//	scanf("%ld", p+i);


		for(int i=1;i<=N+1;i++)
		{
			int j = 0;
			Min = 0xfffffff;
			for (j = 0; j < i; j++)
			{
				double len = p[i] - p[j];
//				e = len>C ? 1.0*C / VT1 + (len - C + 0.0) / VT2 : 1.0*len / VT1;
				if (len>C)
					sum = 1.0*C / VT1 + (len - C) / VT2;
				else
					sum = 1.0*len / VT1;

				
				if (j)
					sum += T;
				sum += dp[j];
				if (Min>sum)
					Min = sum;
				
			}
			dp[i] = Min;
		}
		t1 = L / VR;
		if (t1 > dp[N+1])
			printf("What a pity rabbit!\n");
		else
			printf("Good job,rabbit!\n");		//注意输出格式（特别是空格） 易发生演示错误
	}
	return 0;
}