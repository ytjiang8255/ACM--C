#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#pragma warning(disable: 4996)	//添加的定义排除警告

/*
***************************************************

输入数据包含多个测试实例,每个测试实例占一行,由一个整数N组成，(0<n<=50)
请输出全部的满足要求的涂法，每个实例的输出占一行。
在一涂好的n-1个格子里最后再插入一个格子，就得到了n个格子了。
因为已经填好n-1的格子中，每两个格子的颜色都不相同。
当n=1的情况下 必然只有3种，红，粉，绿
当n=2的情况下 第1个格可以选，红，粉，绿，但第2个格，只能选剩余的两个，因而是2*3=6
当n=3的情况下 第1个格可以选，红，粉，绿，但第2个格，只能选剩余的两个，然而题目说了头尾不能相同那么尾必定只有1中，因而是3*2*1=6
当n=4的情况下 第1个格可以选，红，粉，绿，但第2个格，只能选剩余的两个，之后就要分情况考虑了，
			当第三个格放的是于第一和第二都不相同的，那么第四格格只能放1种 3*2*1*1=6，如果第三格放的跟第一种相同的，第四格就能放2种的了，3*2*2=12  总共有12+6=18种

因而从中我们已经可以看出其满足了一个递推公式: 	a[i]=a[i-1]+a[i-2]*2


第一就是大家熟知的 __int64 用 scanf("%I64d",&a); 读入 
 printf("%I64d\n",a);  输出
 
第二是用long long int 用 scanf("%lld",&a); 读入  printf("%lld\n",a);
***************************************************
*/
int main()
{
	int N;
	long long int a[52];		//!!!注意数组的溢出
	while (scanf("%d", &N) != EOF)
	{
		
//		if ((x >= 1 && x<50 )|| (y >= 1 && y<50))
		for (int i = 0; i<N; i++)
		{
			{
				a[1] = 3;
				a[2] = 6;
				a[3] = 6;
				for (int j = 4; j <= 50; j++)
				{
					a[j] = a[j - 1] + 2*a[j - 2];
				}
			}

			printf("%lld\n", a[N]);

		}

	}
	return 0;
}