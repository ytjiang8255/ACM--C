#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#pragma warning(disable: 4996)	//添加的定义排除警告

/**
测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( < 1000 )和道路数目M；
随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。 
注意:两个城市之间可以有多条道路相通,也就是说
3 3
1 2
1 2
2 1
这种输入也是合法的
当N为0时，输入结束，该用例不被处理。

 
对每个测试用例，在1行里输出最少还需要建设的道路数目。 
4 2
1 3
4 3

>>>1

3 3
1 2
1 3
2 3

>>>0

5 2
1 2
3 5

>>>2

999 0

>>>998

0

**/

int pre[1000 ];
int find(int x)
{
    int r=x;
   while (pre[r]!=r)
   r=pre[r];
   int i=x; int j;
   while(i!=r)
   {
       j=pre[i];
       pre[i]=r;
       i=j;
   }
   return r;
}
int main()
{
   int n,m,p1,p2,i,total,f1,f2;
   while(scanf("%d",&n) && n)         //读入n，如果n为0，结束
   {                                  //刚开始的时候，有n个城镇，一条路都没有 //那么要修n-1条路才能把它们连起来
       total=n-1;
       //每个点互相独立，自成一个集合，从1编号到n //所以每个点的上级都是自己
       for(i=1;i<=n;i++) { pre[i ]=i; }                //共有m条路
       scanf("%d",&m); while(m--)
       { //下面这段代码，其实就是join函数，只是稍作改动以适应题目要求
           //每读入一条路，看它的端点p1，p2是否已经在一个连通分支里了
           scanf("%d %d",&p1,&p2);
           f1=find(p1);
           f2=find(p2);
               //如果是不连通的，那么把这两个分支连起来
               //分支的总数就减少了1，还需建的路也就减了1
           if(f1!=f2)
            {
               pre[f2 ]=f1;
               total--;
           }
           //如果两点已经连通了，那么这条路只是在图上增加了一个环 //对连通性没有任何影响，无视掉
       }
//最后输出还要修的路条数
       printf("%d\n",total);
   }
   return 0;
}
