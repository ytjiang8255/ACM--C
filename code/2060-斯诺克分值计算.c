#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#pragma warning(disable: 4996)	//添加的定义排除警告

/*
***************************************************
船上有21个物体，包括15个红色球和6个彩色球：黄色，绿色，棕色，蓝色，粉色，黑色。
玩家应该使用一个白色的主球，使对象球滚进孔中，球在球上的固定值的总和是玩家的得分。
玩家应该首先把红球放进洞里，然后他获得红球的价值（1分），然后他有机会做一个彩球，然后交替。
所有的红色球都在洞里，应该取出彩色球。换句话说，如果只有彩色球留在板上，
玩家应按此顺序击中物体球：黄色（2点），绿色（3点），棕色（4点），蓝色（5点），粉红色（6分），黑色（7点），
在球进入洞后，他们没有离开洞，没有球留下，游戏结束，
较高的分数赢得比赛。 PS：红色物体球永远不会离开洞。

 所以假设Philp可以继续打球进洞，他可以得到最大的分数
12 * 1（一次射击12个红球）+ 7 * 12（击中红球后，最有价值球的黑球应为目标）
	+ 2 + 3 + 4 + 5 + 6 + 7（ 当没有红球离开时，将所有彩色球放在孔中）。
	
现在，你的任务是判断菲利普是否应当告诉你船上的状况（多少个物体球还没有留在洞里，另一个球员的得分），决定放弃。 
如果Philp仍然有机会赢，只需打印“Yes”，否则打印“No”。 
（PS：如果他能得到的最高分数加上他现在的分数等于对手的当前分数，仍然输出“是”）


第一行包含一个表示总条件的数字N。 然后是N行，每行由三个整数组成：
Ball_Left P_Score O_Score表示球员剩余球数，Philp当前得分和对手当前得分。
所有输入值均为32位整数值范围。计算Philp可以获得的最高分数，并判断他是否有获胜的可能性。
背景：（台球）斯诺克
1.开局有15个红球，6个彩球（黄，绿，棕，蓝，粉，黑）
2.当有红球在场的话，先打红球，再打彩球
3.得数规则是 红（1）,黄（2）,绿（3），棕（4）,蓝（5），粉（6）,黑（7）
内容：
1.输入n（表示有几个案例）
2.输入Ball_Left（剩余的球数），P_Score（前者的分数），O_Score（后者的分数）
3.判断前者是否可能赢过后者，如果能输出“Yes”，否则输出“No”

思路：
1.主要根据剩余的球，计算出最大可以得到的分数
①. 当Ball_Left <=6 ，直接得出结果。 
②. 当Ball_Left >6  ，如果要得到最大的分数，就是说在剩余的红球里，每次都打进黑球，
那么就是最多的了。


***************************************************
*/
int main()
{
	int N,Ball_Left,P_Score,O_Score,s[6]={2,3,4,5,6,7};
	while(scanf("%d",&N) != EOF)
		for(int i=0;i<N;i++)
	{
		int sum=0;
		scanf("%d%d%d", &Ball_Left,&P_Score,&O_Score);
		
		if(Ball_Left==6)	sum=27;
		if(Ball_Left>6)		sum=27+(1+7)*(Ball_Left-6);
		if(Ball_Left<6)		
		{	
			for (int i = 5; i>=6 - Ball_Left; i--)		
				//注意判定条件的‘ = ’
		//	for(int i=5;i>6-Ball_Left;i--)		
				sum +=s[i];
		}
		
		sum += P_Score;
		if(sum>=O_Score)
			printf("YES\n");
		else
			printf("NO\n");
	}
	
	return 0;
}