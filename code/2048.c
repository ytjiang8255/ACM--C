#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#pragma warning(disable: 4996)	//添加的定义排除警告

/*
***************************************************

输入数据的第一行是一个整数C,表示测试实例的个数，
然后是C 行数据，每行包含一个整数n(1<n<=20),表示参加抽奖的人数。
请输出发生这种情况的百分比，每个实例的输出占一行, 
结果保留两位小数(四舍五入)，具体格式请参照sample output。


1. N张字条的所有可能排列自然是N!（分母）。
现在的问题就是求N张字条的错排数f(N)（分子）。
首先我们考虑，如果前面N-1个人拿的都不是自己的票，即前N-1个人满足错排，现在又来了一个人，他手里拿的是自己的票。只要他把自己的票与其他N-1个人中的任意一个交换，就可以满足N个人的错排。这时有(N-1)*f(N-1)种方法。

Besides，我们考虑，如果前N-1个人不满足错排，而第N个人把自己的票与其中一个人交换后恰好满足错排。
这种情况发生在原先N-1人中，N-2个人满足错排，有且仅有一个人拿的是自己的票，而第N个人恰好与他做了交换，这时候就满足了错排。
又因为前N-1个人中，每个人都有机会拿着自己的票。所以有N-1种交换的可能。故这时有(N-1)*f(N-2)种方法。

综上所述：f(N)=(N-1)*[f(N-1)+f(N-2)] 

2. 另一种推导思路是先通过容斥定理直接计算出错排数f(n)=n!(1/2!-1/3!+…..+((-1)^n)/n!)

所以f(n)/n!-f(n-1)/(n-1)!=((-1)^n)/n!

两边同时乘上n!有f(n)-n*f(n-1)=(-1)^n

所以f(n-1)-(n-1)*f(n-2)=(-1)^(n-1)=(-1)*[f(n)-n*f(n-1)]

化简得f(n)=(n-1)*[f(n-1)+f(n-2)] 

3. 通过错位排列数的简化公式D_n= \left\lfloor  \frac{n!}{e}+0.5  \right\rfloor, 来计算（参考维基百科）

***************************************************
*/
long long fac(int n)		//阶乘算法
{
	long long r = n;
	for (int i = n-1; i > 1; --i)
		r *= i;
	return r;
}



int main()
{
	int c, n;
	double  f;
	long long dp[25];
//	dp[1] = 0;
	dp[2] = 1;
	dp[3] = 2;
	for (int i = 4; i < 21; i++)		//		错排公式
		dp[i] = (dp[i - 1] + dp[i - 2])*(i - 1);
	while (scanf("%d", &c) != EOF && c)
	{
		while (c--)
		{
			scanf("%d", &n);
			f = (double)dp[n] / fac(n) * 100;
			printf("%.2lf", f);
			printf("%%\n");		//输出'%' 用的方法是'%%'
		}
	}
	return 0;
}